#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>


#include "vex.h"

using namespace vex;

// Brain should be defined by default
brain Brain;


// START V5 MACROS
#define waitUntil(condition)                                                   \
  do {                                                                         \
    wait(5, msec);                                                             \
  } while (!(condition))

#define repeat(iterations)                                                     \
  for (int iterator = 0; iterator < iterations; iterator++)
// END V5 MACROS


// Robot configuration code.
controller Controller1 = controller(primary);
motor LeftMotorsMotorA = motor(PORT2, ratio18_1, false);
motor LeftMotorsMotorB = motor(PORT9, ratio18_1, false);
motor_group LeftMotors = motor_group(LeftMotorsMotorA, LeftMotorsMotorB);

motor RightMotorsMotorA = motor(PORT10, ratio18_1, true);
motor RightMotorsMotorB = motor(PORT1, ratio18_1, true);
motor_group RightMotors = motor_group(RightMotorsMotorA, RightMotorsMotorB);

motor Arm = motor(PORT5, ratio18_1, false);

motor ShooterMotorA = motor(PORT6, ratio36_1, true);
motor ShooterMotorB = motor(PORT7, ratio36_1, false);
motor_group Shooter = motor_group(ShooterMotorA, ShooterMotorB);

motor Strafe = motor(PORT4, ratio18_1, false);




// Helper to make playing sounds from the V5 in VEXcode easier and
// keeps the code cleaner by making it clear what is happening.
void playVexcodeSound(const char *soundName) {
  printf("VEXPlaySound:%s\n", soundName);
  wait(5, msec);
}



// define variable for remote controller enable/disable
bool RemoteControlCodeEnabled = true;

#pragma endregion VEXcode Generated Robot Configuration

// Include the V5 Library
#include "vex.h"
  
// Allows for easier use of the VEX Library
using namespace vex;

competition Competition;


// TERMS


// User defined function
void myblockfunction_Move_B_2_5_Turns();
// User defined function
void myblockfunction_Start_Shooter();
// User defined function
void myblockfunction_Move_Forward_5_Turns();
// User defined function
void myblockfunction_Move_Forward_4_Turns();
// User defined function
void myblockfunction_Spin_Motors_Forward();
// User defined function
void myblockfunction_set_Motors_velocity_to_50();
// User defined function
void myblockfunction_Turn_Left();
// User defined function
void myblockfunction_Move_Forward_3_Turns();
// User defined function
void myblockfunction_stop_Motors();
// User defined function
void myblockfunction_Move_Forward_2_Turns();
// User defined function
void myblockfunction_Move_Forward_1_Turn();

int Brain_precision = 0, Console_precision = 0, Controller1_precision = 0;

float Distance;

bool x;


// DEFINITIONS


// User defined function
// Decimal points are defined as underscores
void myblockfunction_Move_B_2_5_Turns() {
  LeftMotors.spinFor(reverse, 2.5, turns, false);
  RightMotors.spinFor(reverse, 2.5, turns, true);
}

// User defined function
void myblockfunction_Start_Shooter() {
  LeftMotors.spin(reverse);
}

// User defined function
void myblockfunction_Move_Forward_5_Turns() {
  LeftMotors.spinFor(forward, 5.0, turns, false);
  RightMotors.spinFor(forward, 5.0, turns, true);
}

// User defined function
void myblockfunction_Move_Forward_4_Turns() {
  LeftMotors.spinFor(forward, 4.0, turns, false);
  RightMotors.spinFor(forward, 4.0, turns, true);
}

// User defined function
void myblockfunction_Spin_Motors_Forward() {
  LeftMotors.spin(forward);
  RightMotors.spin(forward);
  Strafe.spin(forward);
}

// User defined function
void myblockfunction_set_Motors_velocity_to_50() {
  LeftMotors.setVelocity(50.0, percent);
  RightMotors.setVelocity(50.0, percent);
}

// User defined function
void myblockfunction_Turn_Left() {
  LeftMotors.spin(reverse);
  RightMotors.spin(forward);
}

// User defined function
void myblockfunction_Move_Forward_3_Turns() {
  LeftMotors.spinFor(forward, 3.0, turns, false);
  RightMotors.spinFor(forward, 3.0, turns, true);
}

// User defined function
void myblockfunction_stop_Motors() {
  LeftMotors.stop();
  RightMotors.stop();
}

// User defined function
void myblockfunction_Move_Forward_2_Turns() {
  LeftMotors.spinFor(forward, 2.0, turns, false);
  RightMotors.spinFor(forward, 2.0, turns, true);
}

// User defined function
void myblockfunction_Move_Forward_1_Turn() {
  LeftMotors.spinFor(forward, 1.0, turns, false);
  RightMotors.spinFor(forward, 1.0, turns, true);
}

// AUTONOMOUS


// "when autonomous" hat block
int onauton_autonomous_0() {
  Brain.Screen.print("AUTONOMOUS");
  RemoteControlCodeEnabled = false;
  LeftMotors.setVelocity(75, percent);
  RightMotors.setVelocity(75, percent);
  LeftMotors.spinFor(forward, 4.2, turns, false);
  RightMotors.spinFor(forward, 4.2, turns, true);
  LeftMotors.spinFor(forward, 325, degrees, false);
  RightMotors.spinFor(reverse, 325, degrees, true);
  Arm.spin(forward);
  wait(0.5, seconds);
  Arm.stop();
  Arm.setStopping(hold);
  wait(0.5, seconds);
  LeftMotors.spinFor(forward, 0.5, turns, false);
  RightMotors.spinFor(forward, 0.5, turns, true);
  LeftMotors.spinFor(reverse, 0.5, turns, false);
  RightMotors.spinFor(reverse, 0.5, turns, true);
  Arm.spin(reverse);
  wait(0.5, seconds);
  Arm.stop();
  LeftMotors.spinFor(reverse, 305, degrees, false);
  RightMotors.spinFor(forward, 305, degrees, true);
  LeftMotors.spinFor(reverse, 2.3, turns, false);
  RightMotors.spinFor(reverse, 2.3, turns, true);
  LeftMotors.spinFor(reverse, 130, degrees, false);
  RightMotors.spinFor(forward, 130, degrees, true);
  LeftMotors.spinFor(reverse, 1.3, turns, false);
  RightMotors.spinFor(reverse, 1.3, turns, true);
  Arm.spin(forward);
  wait(1.5, seconds);
  Arm.stop();
  Arm.setStopping(hold);
  wait(0.5, seconds);
  LeftMotors.setVelocity(40, percent);
  RightMotors.setVelocity(40, percent);
  LeftMotors.spinFor(forward, 1, turns, false);
  RightMotors.spinFor(forward, 1, turns, true);
  Arm.spin(reverse);
  wait(0.5, seconds);
  LeftMotors.setVelocity(75, percent);
  LeftMotors.spinFor(reverse, 1.5, turns, true);
  LeftMotors.setVelocity(100, percent);
  RightMotors.setVelocity(100, percent);
  LeftMotors.spinFor(forward, 3.5, turns, false);
  RightMotors.spinFor(forward, 3.5, turns, true);
  return 0;
}


// WHEN STARTED


// "when started" hat block
int whenStarted1() {
  Controller1.rumble("-.-.");
  Brain.Screen.setCursor(2, 6);
  Brain.Screen.setFillColor(red);
  Brain.Screen.setFont(prop60);
  Arm.setVelocity(25.0, percent);
  Shooter.setVelocity(60.0, percent);
  Shooter.setMaxTorque(1000.0, percent);
  if (Brain.Battery.capacity() == 10.0) {
    Controller1.rumble("----");
    Controller1.Screen.print("Battery Low");
    wait(5.0, seconds);
    Controller1.Screen.clearLine(1);
    Controller1.Screen.setCursor(Controller1.Screen.row(), 1);
  }
  if (LeftMotors.temperature(percent) == 90.0) {
    Controller1.rumble("....");
    Controller1.Screen.print("Left Temp High");
    wait(5.0, seconds);
    Controller1.Screen.clearLine(1);
    Controller1.Screen.setCursor(Controller1.Screen.row(), 1);
  }
  if (RightMotors.temperature(percent) == 90.0) {
    Controller1.rumble("....");
    Controller1.Screen.print("Right Temp High");
    wait(5.0, seconds);
    Controller1.Screen.clearLine(1);
    Controller1.Screen.setCursor(Controller1.Screen.row(), 1);
  }
  return 0;
}


// DRIVER CONTROL


// "when driver control" hat block
int ondriver_drivercontrol_0() {
  Brain.Screen.clearScreen();
  Brain.Screen.print("Oopsie Woopsie, looks like we did a fucksie wucksie. Our code monkeys are working hard to find a sowution. UwU. Code Ewwor: (OxO555802)");
  RemoteControlCodeEnabled = true;
  while (true) {
    // x₁ = Left Motor X = [Controller] [3] position + [Controller] [1] position
    // x₂ = Right Motor X = [Controller] [3] position - [Controller] [1] position
    // Sets each motor's velocity to 0.0001x * |x| (shown as 0.0001 * x * |x|)
    LeftMotors.setVelocity((0.01 * ((Controller1.Axis3.position() + Controller1.Axis1.position()) * fabs(static_cast<float>(Controller1.Axis3.position() + Controller1.Axis1.position())))), percent);
    RightMotors.setVelocity((0.01 * ((Controller1.Axis3.position() - Controller1.Axis1.position()) * fabs(static_cast<float>(Controller1.Axis3.position() - Controller1.Axis1.position())))), percent);
    Strafe.setVelocity(((0.01 * (Controller1.Axis4.position()) * fabs(static_cast<float>(Controller1.Axis4.position())))), percent);
    myblockfunction_Spin_Motors_Forward();
    if (Controller1.ButtonR1.pressing()) {
      Shooter.spin(forward);
    }
    if (Controller1.ButtonR2.pressing()) {
      Shooter.stop();
    }
    if (Controller1.ButtonL1.pressing()) {
      Arm.spin(forward);
    }
    if (Controller1.ButtonL2.pressing()) {
      Arm.spin(reverse);
    }
    if (Controller1.ButtonUp.pressing()) {
      Arm.stop();
      Arm.setMaxTorque(100, percent);
    }
    if (Controller1.ButtonX.pressing()) {
      Shooter.setVelocity(20.0, percent);
      Shooter.spinFor(forward, 150.0, degrees, false);
      Shooter.setVelocity(50.0, percent);
    }
    Arm.setMaxTorque(100.0, percent);
  wait(5, msec);
  }
  if (Brain.Timer.time(seconds) == 10.0) {
    Controller1.rumble(".");
    Controller1.Screen.print("10 Seconds");
    wait(2.0, seconds);
    Controller1.Screen.clearLine(1);
    Controller1.Screen.setCursor(Controller1.Screen.row(), 1);
  }
  return 0;
}


// COMEPTITION CODE


void VEXcode_driver_task() {
  // Start the driver control tasks....
  vex::task drive0(ondriver_drivercontrol_0);
  while(Competition.isDriverControl() && Competition.isEnabled()) {this_thread::sleep_for(10);}
  drive0.stop();
  return;
}

void VEXcode_auton_task() {
  // Start the auton control tasks....
  vex::task auto0(onauton_autonomous_0);
  while(Competition.isAutonomous() && Competition.isEnabled()) {this_thread::sleep_for(10);}
  auto0.stop();
  return;
}



int main() {
  vex::competition::bStopTasksBetweenModes = false;
  Competition.autonomous(VEXcode_auton_task);
  Competition.drivercontrol(VEXcode_driver_task);

  // post event registration

  // set default print color to black
  printf("\033[30m");

  // wait for rotation sensor to fully initialize
  wait(30, msec);

  whenStarted1();
}
